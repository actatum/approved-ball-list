// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"

	"github.com/actatum/approved-ball-list/internal/abl"
)

// Ensure, that RepositoryMock does implement abl.Repository.
// If this is not the case, regenerate this file with moq.
var _ abl.Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of abl.Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked abl.Repository
//		mockedRepository := &RepositoryMock{
//			AddBallsFunc: func(ctx context.Context, balls []abl.Ball) error {
//				panic("mock out the AddBalls method")
//			},
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ListBallsFunc: func(ctx context.Context, filter abl.BallFilter) (abl.ListBallsResult, error) {
//				panic("mock out the ListBalls method")
//			},
//			RemoveBallsFunc: func(ctx context.Context, balls []abl.Ball) error {
//				panic("mock out the RemoveBalls method")
//			},
//		}
//
//		// use mockedRepository in code that requires abl.Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// AddBallsFunc mocks the AddBalls method.
	AddBallsFunc func(ctx context.Context, balls []abl.Ball) error

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ListBallsFunc mocks the ListBalls method.
	ListBallsFunc func(ctx context.Context, filter abl.BallFilter) (abl.ListBallsResult, error)

	// RemoveBallsFunc mocks the RemoveBalls method.
	RemoveBallsFunc func(ctx context.Context, balls []abl.Ball) error

	// calls tracks calls to the methods.
	calls struct {
		// AddBalls holds details about calls to the AddBalls method.
		AddBalls []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Balls is the balls argument value.
			Balls []abl.Ball
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// ListBalls holds details about calls to the ListBalls method.
		ListBalls []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter abl.BallFilter
		}
		// RemoveBalls holds details about calls to the RemoveBalls method.
		RemoveBalls []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Balls is the balls argument value.
			Balls []abl.Ball
		}
	}
	lockAddBalls    sync.RWMutex
	lockClose       sync.RWMutex
	lockListBalls   sync.RWMutex
	lockRemoveBalls sync.RWMutex
}

// AddBalls calls AddBallsFunc.
func (mock *RepositoryMock) AddBalls(ctx context.Context, balls []abl.Ball) error {
	if mock.AddBallsFunc == nil {
		panic("RepositoryMock.AddBallsFunc: method is nil but Repository.AddBalls was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Balls []abl.Ball
	}{
		Ctx:   ctx,
		Balls: balls,
	}
	mock.lockAddBalls.Lock()
	mock.calls.AddBalls = append(mock.calls.AddBalls, callInfo)
	mock.lockAddBalls.Unlock()
	return mock.AddBallsFunc(ctx, balls)
}

// AddBallsCalls gets all the calls that were made to AddBalls.
// Check the length with:
//
//	len(mockedRepository.AddBallsCalls())
func (mock *RepositoryMock) AddBallsCalls() []struct {
	Ctx   context.Context
	Balls []abl.Ball
} {
	var calls []struct {
		Ctx   context.Context
		Balls []abl.Ball
	}
	mock.lockAddBalls.RLock()
	calls = mock.calls.AddBalls
	mock.lockAddBalls.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *RepositoryMock) Close() error {
	if mock.CloseFunc == nil {
		panic("RepositoryMock.CloseFunc: method is nil but Repository.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedRepository.CloseCalls())
func (mock *RepositoryMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// ListBalls calls ListBallsFunc.
func (mock *RepositoryMock) ListBalls(ctx context.Context, filter abl.BallFilter) (abl.ListBallsResult, error) {
	if mock.ListBallsFunc == nil {
		panic("RepositoryMock.ListBallsFunc: method is nil but Repository.ListBalls was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter abl.BallFilter
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockListBalls.Lock()
	mock.calls.ListBalls = append(mock.calls.ListBalls, callInfo)
	mock.lockListBalls.Unlock()
	return mock.ListBallsFunc(ctx, filter)
}

// ListBallsCalls gets all the calls that were made to ListBalls.
// Check the length with:
//
//	len(mockedRepository.ListBallsCalls())
func (mock *RepositoryMock) ListBallsCalls() []struct {
	Ctx    context.Context
	Filter abl.BallFilter
} {
	var calls []struct {
		Ctx    context.Context
		Filter abl.BallFilter
	}
	mock.lockListBalls.RLock()
	calls = mock.calls.ListBalls
	mock.lockListBalls.RUnlock()
	return calls
}

// RemoveBalls calls RemoveBallsFunc.
func (mock *RepositoryMock) RemoveBalls(ctx context.Context, balls []abl.Ball) error {
	if mock.RemoveBallsFunc == nil {
		panic("RepositoryMock.RemoveBallsFunc: method is nil but Repository.RemoveBalls was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Balls []abl.Ball
	}{
		Ctx:   ctx,
		Balls: balls,
	}
	mock.lockRemoveBalls.Lock()
	mock.calls.RemoveBalls = append(mock.calls.RemoveBalls, callInfo)
	mock.lockRemoveBalls.Unlock()
	return mock.RemoveBallsFunc(ctx, balls)
}

// RemoveBallsCalls gets all the calls that were made to RemoveBalls.
// Check the length with:
//
//	len(mockedRepository.RemoveBallsCalls())
func (mock *RepositoryMock) RemoveBallsCalls() []struct {
	Ctx   context.Context
	Balls []abl.Ball
} {
	var calls []struct {
		Ctx   context.Context
		Balls []abl.Ball
	}
	mock.lockRemoveBalls.RLock()
	calls = mock.calls.RemoveBalls
	mock.lockRemoveBalls.RUnlock()
	return calls
}
